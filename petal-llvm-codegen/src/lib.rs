use crate::{
    codegen::{ExpressionCodegen, ExpressionCodegenOptions, StatementCodegen},
    context::CodegenContext,
    error::LLVMCodegenError,
};
use inkwell::{
    AddressSpace, OptimizationLevel,
    builder::Builder,
    context::Context,
    module::Module,
    targets::{CodeModel, FileType, InitializationConfig, RelocMode, Target, TargetMachine},
    types::{BasicMetadataTypeEnum, BasicType, BasicTypeEnum, FunctionType},
    values::BasicValueEnum,
};
use petal_ast::{
    expression::{ExpressionNode, ExpressionNodeKind},
    statement::{StatementNode, StatementNodeKind, TopLevelStatementNode, TopLevelStatementNodeKind},
};
use petal_core::{
    error::Result,
    string_intern::StringInternPool,
    r#type::{ResolvedType, Type, TypeReference, pool::TypePool},
};
use petal_typechecker::temp_resolved_module::ResolvedModule;
use std::{env, mem::ManuallyDrop, path::PathBuf};

pub(crate) mod codegen;
pub(crate) mod context;
pub(crate) mod error;

/// An implementation of a code generator which produces a final binary using LLVM.
pub struct LLVMCodegen<'ctx> {
    /// The [TypePool] to read types from.
    pub(crate) type_pool: &'ctx TypePool,

    /// The StringInternPool implementation to use when reading identifiers.
    pub(crate) string_intern_pool: &'ctx dyn StringInternPool,

    /// The [CodegenContext] used during the compilation.
    pub(crate) context: CodegenContext<'ctx>,

    /// The [LLVMContextHolder] which contains the LLVM [Context] to be used by this codegen.
    pub(crate) llvm_context: &'ctx Context,

    /// The LLVM module being used.
    pub(crate) llvm_module: ManuallyDrop<Module<'ctx>>,

    /// The builder being used.
    pub(crate) llvm_builder: ManuallyDrop<Builder<'ctx>>,
}

impl<'ctx> LLVMCodegen<'ctx> {
    /// Instantiates a new [LLVMCodegen] instance.
    pub fn new(module_name: &str, type_pool: &'ctx TypePool, string_intern_pool: &'ctx dyn StringInternPool) -> Self {
        // We're creating and leaking the LLVM context here. The `Drop` implementation of this struct will ensure that
        // this is cleaned up successfully.
        let llvm_context: &'ctx Context = Box::leak(Box::new(Context::create()));

        LLVMCodegen {
            llvm_context,
            llvm_module: ManuallyDrop::new(llvm_context.create_module(module_name)),
            llvm_builder: ManuallyDrop::new(llvm_context.create_builder()),
            type_pool,
            string_intern_pool,
            context: CodegenContext::new(string_intern_pool),
        }
    }

    /// Visits the provided [ResolvedModule]s, generating LLVM IR for their statements.
    pub fn visit_modules(&mut self, modules: &[ResolvedModule]) -> Result<()> {
        for module in modules {
            for statement in &module.statements {
                self.visit_top_level_statement(statement)?;
            }
        }

        Ok(())
    }

    /// Compiles the generated LLVM module to an object. [LLVMCodegen::visit] must be called to generate code before
    /// calling this method.
    pub fn compile_to_object(&self, dump_bytecode: bool) -> std::result::Result<PathBuf, String> {
        if dump_bytecode {
            println!("{}", self.llvm_module.print_to_string().to_string());
        }

        if let Err(error) = self.llvm_module.verify() {
            return Err(error.to_string());
        }

        // We will write the object file to a temporary path, the caller is responsible for linking the object file into
        // an executable.
        let mut object_file_path = env::temp_dir();
        object_file_path.push(format!("petal-{}.o", self.llvm_module.get_name().to_str().unwrap()));

        // We can then compile the LLVM module into that file path.
        Target::initialize_all(&InitializationConfig::default());

        let triple = TargetMachine::get_default_triple();
        let target = Target::from_triple(&triple).map_err(|it| it.to_string())?;
        let target_machine = target
            .create_target_machine(
                &triple,
                "",
                "",
                OptimizationLevel::None,
                RelocMode::Default,
                CodeModel::Default,
            )
            .ok_or("Failed to create LLVM target machine".to_string())?;

        target_machine
            .write_to_file(&self.llvm_module, FileType::Object, &object_file_path)
            .map_err(|it| it.to_string())?;

        Ok(object_file_path)
    }
}

impl<'ctx> LLVMCodegen<'ctx> {
    /// Visits the provided [TopLevelStatementNode], generating LLVM IR for it.
    pub(crate) fn visit_top_level_statement(&mut self, node: &TopLevelStatementNode) -> Result<()> {
        match &node.kind {
            TopLevelStatementNodeKind::FunctionDeclaration(declaration) => declaration.generate(self, node.span),

            // Import statements do not need to be code-generated by the LLVM module. They are resolved before typechecking.
            TopLevelStatementNodeKind::Import(_) => Ok(()),

            #[allow(unreachable_patterns)]
            _ => return LLVMCodegenError::unprocessable_top_level_statement(node).into(),
        }
    }

    /// Visits the provided [ExpressionNode], generating LLVM IR for it.
    pub(crate) fn visit_expression_with_options(
        &mut self,
        node: &ExpressionNode,
        r#type: BasicTypeEnum<'ctx>,
        options: ExpressionCodegenOptions,
    ) -> Result<BasicValueEnum<'ctx>> {
        match &node.kind {
            ExpressionNodeKind::IntegerLiteral(literal) => literal.generate(self, &r#type, options, node.span),
            ExpressionNodeKind::IdentifierReference(reference) => reference.generate(self, &r#type, options, node.span),
            ExpressionNodeKind::BinaryOperation(operation) => operation.generate(self, &r#type, options, node.span),
            ExpressionNodeKind::FunctionCall(call) => {
                ExpressionCodegen::generate(call, self, &r#type, options, node.span)
            }
            ExpressionNodeKind::StringLiteral(literal) => literal.generate(self, &r#type, options, node.span),

            ExpressionNodeKind::Reference(reference) => {
                // We must visit the inner expression with a reference type.
                self.visit_expression_with_options(
                    &reference.value,
                    self.llvm_context.ptr_type(AddressSpace::default()).as_basic_type_enum(),
                    ExpressionCodegenOptions::as_reference(),
                )
            }

            ExpressionNodeKind::BooleanLiteral(literal) => literal.generate(self, &r#type, options, node.span),

            #[allow(unreachable_patterns)]
            _ => return LLVMCodegenError::unprocessable_expression(node).into(),
        }
    }

    pub(crate) fn visit_expression(&mut self, node: &ExpressionNode) -> Result<BasicValueEnum<'ctx>> {
        let r#type = node.r#type.map(|it| self.get_basic_llvm_type(&it)).expect("")?;
        self.visit_expression_with_options(node, r#type, ExpressionCodegenOptions::default())
    }

    /// Visits the provided [StatementNode], generating LLVM IR for it.
    pub(crate) fn visit_statement(&mut self, node: &StatementNode) -> Result<()> {
        match &node.kind {
            StatementNodeKind::Return(r#return) => r#return.generate(self, node.span),
            StatementNodeKind::VariableDeclaration(declaration) => declaration.generate(self, node.span),
            StatementNodeKind::VariableAssignment(assignment) => assignment.generate(self, node.span),
            StatementNodeKind::FunctionCall(call) => StatementCodegen::generate(call, self, node.span),
            StatementNodeKind::If(r#if) => r#if.generate(self, node.span),
            StatementNodeKind::WhileLoop(while_loop) => while_loop.generate(self, node.span),

            #[allow(unreachable_patterns)]
            _ => return LLVMCodegenError::unprocessable_statement(node).into(),
        }
    }

    /// Attempts to get the resolved type behind the provided [TypeReference].
    pub(crate) fn get_resolved_type(&self, reference: &TypeReference) -> Result<&ResolvedType> {
        let resolved_type = match self.type_pool.get_type_or_err(&reference.id, reference.span)? {
            Type::Resolved(resolved) => resolved,
            _ => return LLVMCodegenError::unresolved_type(reference).into(),
        };

        Ok(resolved_type)
    }

    /// Attempts to get the resolved type behind the provided [TypeReference], and converts it to a [BasicTypeEnum].
    pub(crate) fn get_basic_llvm_type(&self, reference: &TypeReference) -> Result<BasicTypeEnum<'ctx>> {
        let basic_type = match self.get_resolved_type(reference)? {
            ResolvedType::UnsignedInteger(size) | ResolvedType::SignedInteger(size) => {
                self.llvm_context.custom_width_int_type(*size).as_basic_type_enum()
            }

            ResolvedType::Reference(_) => self.llvm_context.ptr_type(AddressSpace::default()).as_basic_type_enum(),

            ResolvedType::Boolean => self.llvm_context.bool_type().as_basic_type_enum(),

            r#type => return LLVMCodegenError::unprocessable_type(r#type.clone(), reference.span).into(),
        };

        Ok(basic_type)
    }

    /// Attempts to create a function type from the provided [TypeReference]s for the return type and parameter types.
    pub(crate) fn create_function_type(
        &self,
        return_type: &TypeReference,
        parameter_types: &[TypeReference],
    ) -> Result<FunctionType<'ctx>> {
        // Each parameter must be resolvable to a basic type.
        let parameters: Vec<BasicMetadataTypeEnum<'ctx>> = parameter_types
            .iter()
            .map(|it| self.get_basic_llvm_type(it).map(|it| it.into()))
            .collect::<Result<Vec<_>>>()?;

        Ok(match self.get_resolved_type(return_type)? {
            ResolvedType::Void => self.llvm_context.void_type().fn_type(&parameters, false),

            ResolvedType::UnsignedInteger(size) | ResolvedType::SignedInteger(size) => self
                .llvm_context
                .custom_width_int_type(*size)
                .fn_type(&parameters, false),

            ResolvedType::Reference(_) => self
                .llvm_context
                .ptr_type(AddressSpace::default())
                .fn_type(&parameters, false),

            ResolvedType::Boolean => self.llvm_context.bool_type().fn_type(&parameters, false),

            r#type => return LLVMCodegenError::unprocessable_type(r#type.clone(), return_type.span).into(),
        })
    }
}

/// The drop implementation ensures that the context that was leaked in the constructor is cleaned up properly.
impl<'ctx> Drop for LLVMCodegen<'ctx> {
    fn drop(&mut self) {
        unsafe {
            // SAFETY: These values are not dropped anywhere other than in this method. This means that these values are
            // valid during all execution up until the struct holding them is dropped.
            ManuallyDrop::drop(&mut self.llvm_builder);
            ManuallyDrop::drop(&mut self.llvm_module);

            // SAFETY: We know that the `llvm_context` within the codegen was created using [Box::leak] in the `new`
            // factory function. We have also already dropped the builder and module manually.
            let context_box = Box::from_raw(self.llvm_context as *const Context as *mut Context);
            drop(context_box);
        }
    }
}
